<script src=lib1.js></script>


<script id='my_vertex_shader1' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader1' type='x-shader/x-fragment'>

   precision mediump float;
   uniform float uTime;
   uniform vec3  uCursor;
   varying vec3  vPosition;

   vec3 Lrgb[3];
   vec3 Ldir[3];
   float mode = 1.; //select mode=1. to phong or mode=2. to blinn

   vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
   vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
   vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

   float noise(vec3 P) {
	   vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
	   vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
	   vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
	   vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
	   vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
	   vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
	   vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
	   gx0 = fract(gx0); gx1 = fract(gx1);
	   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
	   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
	   gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
	   gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
	   vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
		    g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
		    g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
		    g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
	   vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
	   vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
	   g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
	   g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
	   vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
		                  dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
		             vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
		                  dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
	   return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
   }

   float rayPlane(vec3 V, vec3 W, vec4 p) {
      return -( dot( p.xyz, V ) + p.w ) / dot( p.xyz, W );
   }

   vec3 shadePlane(vec3 point, vec4 plane, vec3 material, vec3 W) {
      vec3 color = vec3(0.,0.,0.);
      vec3 ambient = material / 5.;
      vec3 diffuse = vec3(1.1,1.1,1.1);
      vec3 s = vec3((1.,1.,1.));
      vec3 normal = normalize(plane.xyz);  //(point - plane.xyz) / plane.w;  //VERIFY!!!
      vec3 lightsum = vec3(0.0,0.0,0.0);
      float p;
	  if (mode ==1.){  //phong
          
          p = 20.;      
          //sum the multiple light souces
          for (int j = 0; j < 1; j++){
              vec3 R = 2. * dot(normal, Ldir[j]) * normal - Ldir[j]; //Reflectance
              lightsum += Lrgb[j] * ( diffuse * max(0., dot(normal, Ldir[j])) + s.rgb * pow(max(0., dot(W, R)), p) ) ;
          }   
	      color = ambient + lightsum;

      }else{  //blinn

          p = 30.;
          //sum the multiple light souces
          for (int j = 0; j < 1; j++){
              vec3 H = normalize(Ldir[j] + W);
              lightsum += Lrgb[j] * ( diffuse * max(0., dot(normal, Ldir[j])) + s.rgb * pow(max(0., dot(normal, H)), p) ) ;
          }   
	      color = ambient + lightsum;
      }

      return color;
   }

   void main(void) {
      vec2 c = uCursor.xy;

      //Create multiple Light souces
      for (int j = 0; j < 1; j++){
          Lrgb[j] = vec3(float(j)/6.+0.3,1.,float(j)/6.+0.3);
          Ldir[j] = normalize(vec3(float(j)-1., 1., 1. - 2. * dot(c, c)));
      }
      Lrgb[0] = vec3(0.5,0.5,0.5);
      Ldir[0] = normalize(vec3(0.,0.,-10.));
      vec3 V, W;
      float f = -1.10;
      V = vec3(0.,0.,-7.);
      W = normalize( vec3(vPosition.x, vPosition.y, -f) );
      vec3 color = vec3(0., 0., 0.);
      for (int j=0; j<20; j++){
          float e1 = noise(vec3(float(j)+uTime * .15 , float(j)+uTime * .15, 10.));
          float e2 = noise(vec3(float(j)+uTime * .3 , float(j)+uTime * .3, 10.));
		  vec4 planes[6];
		  //planes[0] = vec4( 1., 1., 0.,-0.4-2.*c.x); 
		  //planes[1] = vec4(-1., -1., 0.,-0.4+2.*c.x); 
		  //planes[2] = vec4( -1., 1., 0.,-0.4-2.*c.y);
		  //planes[3] = vec4( 1.,-1., 0.,-0.4+2.*c.y);

		  //planes[0] = vec4( 1., sin(uTime), 0.,-0.4-2.*c.x-20.*e); 
		  //planes[1] = vec4(-1., -sin(uTime), 0.,-0.4+2.*c.x+20.*e); 
		  //planes[2] = vec4( -sin(uTime), 1., 0.,-0.4-2.*c.y);
		  //planes[3] = vec4( sin(uTime),-1., 0.,-0.4+2.*c.y);
          planes[0] = vec4( 1., 0., 0.,-0.4-2.*c.x-20.*e1); 
		  planes[1] = vec4(-1., 0., 0.,-0.4+2.*c.x+20.*e1); 
		  planes[2] = vec4( 0., 1., 0.,-0.4-2.*c.y-20.*e2 - 20.+mod(5.*uTime,40.));
		  planes[3] = vec4( 0.,-1., 0.,-0.4+2.*c.y+20.*e2 + 20.-mod(5.*uTime,40.));		 
          planes[4] = vec4( 0., 0., 1.,-.4);
		  planes[5] = vec4( 0., 0.,-1.,-.4);

		  vec3 material= vec3(1.-float(j)/20.,0.5+0.5*float(j)/20.,0.5+0.5*float(j)/20.);
		  
		  float t[6];
		  float tin[6];
		  float tout[6];
		  int miss = 0;
		  for (int i=0; i<6; i++){
		      t[i] = rayPlane(V, W, planes[i]);
		   //   if (t[i] > 0.) {
		          if ( dot( planes[i].xyz, W ) < 0. ){ //if the ray is going into half space:          
		              tin[i] = t[i];
		              tout[i] = 10000.;
		          }
		          if ( dot( planes[i].xyz, W ) > 0. ){  //if the ray is going out half space:
		              tin[i] = 0.;
		              tout[i] = t[i];
		          }
		          if ( dot( planes[i].xyz, W ) == 0. ){  //if the ray is parallel to half space:
		              if ( dot( planes[i].xyz, V ) + planes[i].w <= 0. ){   //if the ray is completely inside half space:
		                  tin[i] = 0.; //ignore this half-space
		                  tout[i] = 10000.; //ignore this half-space
		              }else{    //if the ray is completely outside half space:
		                  miss = 1;
		              }
		          }
		     // }else{
		      //    tin[i] = 0.; //ignore this half-space
		     //     tout[i] = 10000.; //ignore this half-space
		    //  }
		  }
	 
		  float tinmax = 0.;
		  float toutmin = 10000.;
		  vec4 planeref;
		  for (int i =0; i<6; i++){
		      if (tin[i]>tinmax){
		          planeref = planes[i];
		          tinmax = tin[i];
		      }
		      if (tout[i]<toutmin){
		          toutmin = tout[i];
		      }
		  }

		  if ( tinmax<toutmin && miss==0 ){
		      color = shadePlane(V + tinmax * W, planeref, material, W);
		  }
		  gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
      }   
    }
</script>


<script id='my_vertex_shader7' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader7' type='x-shader/x-fragment'>

   precision mediump float;
   uniform float uTime;
   uniform vec3  uCursor;
   varying vec3  vPosition;

   vec3 Lrgb[3];
   vec3 Ldir[3];
   float mode = 1.; //select mode=1. to phong or mode=2. to blinn


   vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
   vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
   vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

   float noise(vec3 P) {
	   vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
	   vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
	   vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
	   vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
	   vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
	   vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
	   vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
	   gx0 = fract(gx0); gx1 = fract(gx1);
	   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
	   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
	   gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
	   gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
	   vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
		    g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
		    g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
		    g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
	   vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
	   vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
	   g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
	   g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
	   vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
		                  dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
		             vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
		                  dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
	   return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
   }
 
   float turbulence(vec3 p) { 
       float sum=0.;
       for (int i =0; i<6; i++){
           sum += abs( noise( pow(2.,float(i)) * p ) ) / pow(2.,float(i));
       }
       return sum;
   }

   float rayPlane(vec3 V, vec3 W, vec4 p) {

      return -( dot( p.xyz , V ) + p.w ) / dot( p.xyz , W );
   }

   vec3 shadePlane(vec3 point, vec4 plane, vec3 material, vec3 W) {
      float e = noise(vec3(vPosition.x * 15. , vPosition.y * 15., 10.));
      vec3 color = vec3(0.,0.,0.);
      vec3 ambient = material / 5. ;
      vec3 diffuse = vec3(0.4,0.4,0.4);
      vec3 s = vec3((1.,1.,1.));
      
      vec3 normal = normalize(plane.xyz+(2.+1.*e));  //(point - plane.xyz) / plane.w;  //VERIFY!!!
      vec3 lightsum = vec3(0.0,0.0,0.0);
      float p;
	  if (mode ==1.){  //phong
          
          p = 10.;      
          //sum the multiple light souces
          for (int j = 0; j < 1; j++){
              vec3 R = 2. * dot(normal, Ldir[j]) * normal - Ldir[j]; //Reflectance
              lightsum += Lrgb[j] * ( diffuse * max(0., dot(normal, Ldir[j])) + s.rgb * pow(max(0., dot(W, R)), p) ) ;
          }   
	      color = ambient + lightsum;

      }else{  //blinn

          p = 30.;
          //sum the multiple light souces
          for (int j = 0; j < 1; j++){
              vec3 H = normalize(Ldir[j] + W);
              lightsum += Lrgb[j] * ( diffuse * max(0., dot(normal, Ldir[j])) + s.rgb * pow(max(0., dot(normal, H)), p) ) ;
          }   
	      color = ambient + lightsum;
      }

      return color;
   }

   void main(void) {
      vec2 c = uCursor.xy;

      //Create multiple Light souces
      for (int j = 0; j < 1; j++){
          Lrgb[j] = vec3(float(j)/6.+0.3,1.,float(j)/6.+0.3);
          Ldir[j] = normalize(vec3(float(j)-1., 1., 1. - 2. * dot(c, c)));
      }
      Lrgb[0] = vec3(1.0,0.5,0.5);
      Ldir[0] = normalize(vec3(0.,0.,-1.));
      vec3 V, W;
      float f = -1.10;
      V = vec3(0.,0.,-3.);
      W = normalize( vec3(vPosition.x, vPosition.y, -f) );
      vec4 planes[6];
      float e = noise(vec3(vPosition.x * 15. , vPosition.y * 15., 10.));
      planes[0] = vec4( 1.+0.04*e, 0., 0.,-1.8-2.*c.x);
      planes[1] = vec4(-1.+0.04*e, 0., 0.,-1.8+2.*c.x);
      planes[2] = vec4( 0., 1.+0.04*e, 0.,-0.1-2.*c.y);
      planes[3] = vec4( 0.,-1.+0.04*e, 0.,-0.1+2.*c.y);
      planes[4] = vec4( 0., 0., 1.+0.04*e,-10.4);
      planes[5] = vec4( 0., 0.,-1.+0.04*e,-1.4);

      vec3 material= vec3(0.7,0.0,0.0);
      vec3 color = vec3(0., 0., 0.);
      float t[6];
      float tin[6];
      float tout[6];
      int miss = 0;
      for (int i=0; i<6; i++){
          t[i] = rayPlane(V, W, planes[i]);
              if ( dot( planes[i].xyz, W ) < 0. ){ //if the ray is going into half space:          
                  tin[i] = t[i];
                  tout[i] = 10000.;
              }
              if ( dot( planes[i].xyz, W ) > 0. ){  //if the ray is going out half space:
                  tin[i] = 0.;
                  tout[i] = t[i];
              }
              if ( dot( planes[i].xyz, W ) == 0. ){  //if the ray is parallel to half space:
                  if ( dot( planes[i].xyz, V ) + planes[i].w <= 0. ){   //if the ray is completely inside half space:
                      tin[i] = 0.; //ignore this half-space
                      tout[i] = 10000.; //ignore this half-space
                  }else{    //if the ray is completely outside half space:
                      miss = 1;
                  }
              }
      }

      float tinmax = 0.;
      float toutmin = 10000.;
      vec4 planeref;
      for (int i =0; i<6; i++){
          if (tin[i]>tinmax){
              planeref = planes[i];
              tinmax = tin[i];
          }
          if (tout[i]<toutmin){
              toutmin = tout[i];
          }
      }

      if ( tinmax<toutmin && miss==0 ){
          color = shadePlane(V + tinmax * W, planeref, material, W);
      }
      gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
   }
</script>



<script id='my_vertex_shader8' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader8' type='x-shader/x-fragment'>

   precision mediump float;
   uniform float uTime;
   uniform vec3  uCursor;
   varying vec3  vPosition;

   vec3 Lrgb[3];
   vec3 Ldir[3];
   float mode = 1.; //select mode=1. to phong or mode=2. to blinn

   float rayPlane(vec3 V, vec3 W, vec4 p) {
      return -( dot( p.xyz , V ) + p.w ) / dot( p.xyz , W );
   }

   // Compute intersection of a ray with a sphere, if any.  Return t.
   // If there is no intersection, return 10000.
   float rayCilinder(vec3 V, vec3 W, vec4 s) {
      float a = W.x*W.x + W.z*W.z;
      float b = 2. * dot(V.xz -= s.xz, W.xz);
      float c = dot(V, V) - s.w * s.w;
      float d = b * b - 4. * a * c;
      return d < 0. ? 1. / 0. : (-b + sqrt(d)) / (2. * a);
   }

   vec3 shadeCilinder(vec3 point, vec4 cilinder, vec3 material, vec3 W) {
      vec3 color = vec3(0.,0.,0.);
      vec3 ambient = material / 5.;
      vec3 diffuse = vec3(0.4,0.4,0.4);
      vec3 s = vec3((1.,1.,1.));
      vec3 normal = (point.xyz - cilinder.xyz ) / cilinder.w;
      normal = vec3(normal.x, 0., normal.z);
      vec3 lightsum = vec3(0.0,0.0,0.0);
      float p;
	  if (mode ==1.){  //phong
          
          p = 10.;      
          //sum the multiple light souces
          for (int j = 0; j < 1; j++){
              vec3 R = 2. * dot(normal, Ldir[j]) * normal - Ldir[j]; //Reflectance
              lightsum += Lrgb[j] * ( diffuse * max(0., dot(normal, Ldir[j])) + s.rgb * pow(max(0., dot(W, R)), p) ) ;
          }   
	      color = ambient + lightsum;

      }else{  //blinn

          p = 30.;
          //sum the multiple light souces
          for (int j = 0; j < 1; j++){
              vec3 H = normalize(Ldir[j] + W);
              lightsum += Lrgb[j] * ( diffuse * max(0., dot(normal, Ldir[j])) + s.rgb * pow(max(0., dot(normal, H)), p) ) ;
          }   
	      color = ambient + lightsum;
      }

      return color;
   }

   vec3 shadePlane(vec3 point, vec4 plane, vec3 material, vec3 W) {
      vec3 color = vec3(0.,0.,0.);
      vec3 ambient = material / 5.;
      vec3 diffuse = vec3(0.4,0.4,0.4);
      vec3 s = vec3((1.,1.,1.));
      vec3 normal = normalize(plane.xyz);
      vec3 lightsum = vec3(0.0,0.0,0.0);
      float p;
	  if (mode ==1.){  //phong
          p = 10.;      
          //sum the multiple light souces
          for (int j = 0; j < 1; j++){
              vec3 R = 2. * dot(normal, Ldir[j]) * normal - Ldir[j]; //Reflectance
              lightsum += Lrgb[j] * ( diffuse * max(0., dot(normal, Ldir[j])) + s.rgb * pow(max(0., dot(W, R)), p) ) ;
          }   
	      color = ambient + lightsum;
      }else{  //blinn
          p = 30.;
          //sum the multiple light souces
          for (int j = 0; j < 1; j++){
              vec3 H = normalize(Ldir[j] + W);
              lightsum += Lrgb[j] * ( diffuse * max(0., dot(normal, Ldir[j])) + s.rgb * pow(max(0., dot(normal, H)), p) ) ;
          }   
	      color = ambient + lightsum;
      }

      return color;
   }

   void main(void) {
      vec2 c = uCursor.xy;

      //Create multiple Light souces
      for (int j = 0; j < 1; j++){
          Lrgb[j] = vec3(float(j)/6.+0.3,1.,float(j)/6.+0.3);
          Ldir[j] = normalize(vec3(float(j)-1., 1., 1. - 2. * dot(c, c)));
      }
      Lrgb[0] = vec3(0.5,0.5,0.5);
      //Ldir[0] = normalize(vec3(c.x, c.y, 1. - 2. * dot(c, c)));
      Ldir[0] = normalize(vec3(0., 0.5, -5.));
      vec3 V, W;
      float f = -1.10;
      V = vec3(0.,0.,-3.);
      W = normalize( vec3(vPosition.x, vPosition.y, -f) );
      vec4 planes[6];
      //planes[0] = vec4( 0., 1., 0.,-1.4-2.*c.y);
      //planes[1] = vec4( 0.,-1., 0.,-1.4+2.*c.y);
      planes[0] = vec4( 1., 0., 0.,-10.8-2.*c.x);
      planes[1] = vec4(-1., 0., 0.,-10.8+2.*c.x);
      planes[2] = vec4( 0., 1., 0.,-1.-2.*c.y);
      planes[3] = vec4( 0.,-1., 0.,-1.+2.*c.y);
      planes[4] = vec4( 0., 0., 1.,-.0004);
      planes[5] = vec4( 0., 0.,-1.,-.0004);

      vec4 cilinder = vec4(0.+2.*c.x, 0., 0., .5); //x,y,z,r
      vec3 material= vec3(0.7,0.0,0.0);
      vec3 color = vec3(0., 0., 0.);
      float t[6];
      float tin[6];
      float tout[6];
      int miss = 0;
      for (int i=0; i<6; i++){
          t[i] = rayPlane(V, W, planes[i]);
          if ( dot( planes[i].xyz, W ) < 0. ){ //if the ray is going into half space:          
              tin[i] = t[i];
              tout[i] = 10000.;
          }
          if ( dot( planes[i].xyz, W ) > 0. ){  //if the ray is going out half space:
              tin[i] = 0.;
              tout[i] = t[i];
          }
          if ( dot( planes[i].xyz, W ) == 0. ){  //if the ray is parallel to half space:
              if ( dot( planes[i].xyz, V ) + planes[i].w <= 0. ){   //if the ray is completely inside half space:
                  tin[i] = 0.; //ignore this half-space
                  tout[i] = 10000.; //ignore this half-space
              }else{    //if the ray is completely outside half space:
                  miss = 1;
              }
          }
      }

      float tinmax = 0.;
      float toutmin = 10000.;
      vec4 planeref;
      for (int i=0; i<6; i++){
          if (tin[i]>tinmax){
              planeref = planes[i];
              tinmax = tin[i];
          }
          if (tout[i]<toutmin){
              toutmin = tout[i];
          }
      }

      float tcilinder = rayCilinder(V, W, cilinder);
      if ( tcilinder < 10000. && tinmax < toutmin && miss == 0 ){
          //if (tcilinder < tinmax){
              color = shadeCilinder(V + tcilinder * W, cilinder, material, W);
          //}else{
          //    color = shadePlane(V + tinmax * W, planeref, material, W);
          //}
      }
      gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
   }
</script>



<script id='my_vertex_shader2' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader2' type='x-shader/x-fragment'>

   precision mediump float;
   uniform float uTime;
   uniform vec3  uCursor;
   varying vec3  vPosition;

   vec4 sphere1;
   vec4 sphere2;
   vec3 material;

   vec3 Lrgb;
   vec3 Ldir;
   float mode = 2.; //select mode=1. to phong or mode=2. to blinn
   // Compute intersection of a ray with a sphere, if any.  Return t.
   // If there is no intersection, return 10000.

 
   vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
   vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
   vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

   float noise(vec3 P) {
	   vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
	   vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
	   vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
	   vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
	   vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
	   vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
	   vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
	   gx0 = fract(gx0); gx1 = fract(gx1);
	   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
	   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
	   gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
	   gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
	   vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
		    g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
		    g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
		    g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
	   vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
	   vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
	   g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
	   g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
	   vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
		                  dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
		             vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
		                  dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
	   return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
   }
 
   float turbulence(vec3 p) { 
       float sum=0.;
       for (int i =0; i<6; i++){
           sum += abs( noise( pow(2.,float(i)) * p ) ) / pow(2.,float(i));
       }
       return sum;
   }
   float raySphere(vec3 V, vec3 W, vec4 s) {
      float b = 2. * dot(V -= s.xyz, W);
      float c = dot(V, V) - s.w * s.w;
      float d = b * b - 4. * c;
      return d < 0. ? 1. / 0. : (-b + sqrt(d)) / 2.;
   }


   // Diffusely shade a sphere.
   //    point is the x,y,z position of the surface point.
   //    sphere is the x,y,z,r definition of the sphere.
   //    material is the r,g,b color of the sphere.

   vec3 shadeSphere(vec3 point, vec4 sphere, vec3 material, vec3 W) {
      vec3 color = vec3(0.,0.,0.);
      vec3 ambient = material / 5.;
      vec3 diffuse = vec3(0.4,0.4,0.4);
      vec3 s = vec3((1.,1.,1.));
      vec3 normal = (point - sphere.xyz) / sphere.w;
      float p;
	  if (mode ==1.){  //phong
          vec3 R = 2. * dot(normal, Ldir) * normal - Ldir; //Reflectance
          p = 10.;
		  color = ambient + Lrgb * ( diffuse * max(0., dot(normal, Ldir)) + s.rgb * pow(max(0., dot(W, R)), p) ) ; //put the pow inside max 
      }else{  //blinn
          vec3 H = normalize(Ldir + W);
          p = 30.;
          color = ambient + Lrgb * ( diffuse * max(0., dot(normal, Ldir)) + s.rgb * pow(max(0., dot(normal, H)), p) ) ; //put the pow inside max 
      }

      return color;
   }

   void main(void) {
      vec2 c = uCursor.xy;

      Lrgb = vec3(0.5,0.5,0.5);
      Ldir = normalize(vec3(c.x, c.y, 1. - 2. * dot(c, c)));
      
      // YOU NEED TO COMPUTE V AND W TO CREATE THE RAY FOR THIS PIXEL,
      // USING vPosition.x AND vPosition.y.
 
      vec3 V, W;
      float f = -10.0;
      W = normalize( vec3(vPosition.x, vPosition.y, -f) );
      V = vec3(0.,0.,0.);
      vec4 spheres[3];
      spheres[0] = vec4(.0,.0,5.,.5); //vec4(x,y,z,r)
      spheres[1] = vec4(0.5*c.x,0.5*c.y,5.,.05); //vec4(x,y,z,r)
      spheres[2] = vec4(-.2,.0,5.,.1); //vec4(x,y,z,r)

      vec3 materials[3];
      materials[0] = vec3(0.7,0.0,0.0);
      materials[1] = vec3(0.0,0.7,0.0);
      materials[2] = vec3(0.0,0.0,0.7);
      vec3 color = vec3(0., 0., 0.);

      float vin[2];
      float vout[2];
      for (int i=0; i<1;i++){
          float t = raySphere(V, W, spheres[i]);
          if (t < 10000.){
              //vin[i] = t[0]; //used to do boolean intersection
              //vout[i] = t[1]; //used to do boolean intersection
              vec3 point = V + t * W ;
              vec3 Vprime = point + 0.0001;
              vec3 Wprime = Ldir;
              vec3 normal = (point - spheres[i].xyz) / spheres[i].w;
              float tprimeMin = 10000.;
              for (int j =0; j<1;j++){
                  if (j!=i){
                      float tprime = raySphere(Vprime, Wprime, spheres[j]);
                      if (tprime <tprimeMin){
                         tprimeMin = tprime;
                      }
                  }
              }
              if (tprimeMin == 10000.){ //if no object is in the way of the ray
                  color = shadeSphere(V + t * W, spheres[i], materials[i], W) ;
                  //do reflection
                  vec3 colorrfl = vec3(0., 0., 0.);
                  float trflMin = 10000.;
                  float trfl;
                  vec3 Wrfl = 2. * dot(normal, -W) * normal + W;
                  vec3 Vrfl = point + 0.0001 * Wrfl;
                  float trfl2 = raySphere(Vrfl, Wrfl, spheres[i]); 
                  for (int j =0; j<1;j++){
                      if (j!=i){
                           trfl = raySphere(Vrfl, Wrfl, spheres[j]);
                           if (trfl < trflMin && trfl <trfl2){
                               trflMin = trfl;
                               colorrfl = shadeSphere(Vrfl + trflMin * Wrfl, spheres[j], materials[j], Wrfl);
                               
                           }
                      }
                  }
      /*            
                  float u = 0.4 * (turbulence(vec3(vPosition.x * 1.5+uTime/5., vPosition.y * 1.5, uTime/5.+10.)) + 1.8);
                  //float s = sin(uTime)+pow(0.5 + 0.5 * sin(4.  * vPosition.x + 6. * u) * cos(4. * vPosition.y + 6. * u), 1.1); //use this later! its cool
                  float s = pow(0.5 + 0.5 * sin(4. * vPosition.x + 6. * u) * cos(4. * vPosition.y + 6. * u), 1.1);
                  color = vec3(s, s*s, s*s*s);
                  colorrfl = vec3(.1,.1,0.9);   
                  color = mix(color , colorrfl, 0.3);
     */             
              }
          }
      }
      //do boolean intersection
      //float tin = max(vin[0],vin[1]);
      //float tout = min(vout[0],vout[1]);
      //if (tin >= tout){
      //     color = vec3(0.,0.,0.);
      //}
      float u = 0.4 * (turbulence(vec3(vPosition.x * 1.+uTime/3., vPosition.y * 1.5, uTime/10.+10.)) + 1.8);
      float s = pow(0.5 + 0.5 * sin(4. * vPosition.x +uTime/2.+ 6. * u) * cos(4. * vPosition.y+uTime/2. + 6. * u), 1.1);
      color = vec3(s, s*s, s*s*s);
      vec3 colorrfl2 = vec3(.2,.2,0.7);   
      color = mix(color , colorrfl2, 0.6);

      //maybe remove here
      float u2 = 0.4 * (turbulence(vec3(vPosition.x * 1.+uTime/5.+10., vPosition.y * 1.5, uTime/10.+10.)) + 1.8);
      float s2 = pow(0.5 + 0.5 * sin(4. * vPosition.x +uTime/2.+ 6. * u2) * cos(4. * vPosition.y+uTime/2. + 6. * u2), 1.1);
      vec3 color2 = vec3(s2, s2*s2, s2*s2*s2);
      vec3 colorrfl3 = vec3(.2,.2,0.7);   
      color2 = mix(color2 , colorrfl3, 0.6);

      color = mix(color , color2, 0.5);

      gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
   }
</script>


<script id='my_vertex_shader4' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader4' type='x-shader/x-fragment'>

   precision mediump float;
   uniform float uTime;
   uniform vec3  uCursor;
   varying vec3  vPosition;

   vec4 sphere1;
   vec4 sphere2;
   vec3 material;

   vec3 Lrgb;
   vec3 Ldir;
   float mode = 2.; //select mode=1. to phong or mode=2. to blinn
   // Compute intersection of a ray with a sphere, if any.  Return t.
   // If there is no intersection, return 10000.

 
   vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
   vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
   vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

   float noise(vec3 P) {
	   vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
	   vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
	   vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
	   vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
	   vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
	   vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
	   vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
	   gx0 = fract(gx0); gx1 = fract(gx1);
	   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
	   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
	   gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
	   gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
	   vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
		    g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
		    g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
		    g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
	   vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
	   vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
	   g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
	   g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
	   vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
		                  dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
		             vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
		                  dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
	   return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
   }
 
   float turbulence(vec3 p) { 
       float sum=0.;
       for (int i =0; i<6; i++){
           sum += abs( noise( pow(2.,float(i)) * p ) ) / pow(2.,float(i));
       }
       return sum;
   }
   float raySphere(vec3 V, vec3 W, vec4 s) {
      float b = 2. * dot(V -= s.xyz, W);
      float c = dot(V, V) - s.w * s.w;
      float d = b * b - 4. * c;
      return d < 0. ? 1. / 0. : (-b + sqrt(d)) / 2.;
   }


   // Diffusely shade a sphere.
   //    point is the x,y,z position of the surface point.
   //    sphere is the x,y,z,r definition of the sphere.
   //    material is the r,g,b color of the sphere.

   vec3 shadeSphere(vec3 point, vec4 sphere, vec3 material, vec3 W) {
      vec3 color = vec3(0.,0.,0.);
      vec3 ambient = material / 5.;
      vec3 diffuse = vec3(0.4,0.4,0.4);
      vec3 s = vec3((1.,1.,1.));
      vec3 normal = (point - sphere.xyz) / sphere.w;
      float p;
	  if (mode ==1.){  //phong
          vec3 R = 2. * dot(normal, Ldir) * normal - Ldir; //Reflectance
          p = 10.;
		  color = ambient + Lrgb * ( diffuse * max(0., dot(normal, Ldir)) + s.rgb * pow(max(0., dot(W, R)), p) ) ; //put the pow inside max 
      }else{  //blinn
          vec3 H = normalize(Ldir + W);
          p = 30.;
          color = ambient + Lrgb * ( diffuse * max(0., dot(normal, Ldir)) + s.rgb * pow(max(0., dot(normal, H)), p) ) ; //put the pow inside max 
      }

      return color;
   }

   void main(void) {
      vec2 c = uCursor.xy;

      Lrgb = vec3(0.5,0.5,0.5);
      Ldir = normalize(vec3(c.x, c.y, 1. - 2. * dot(c, c)));
      
      vec3 V, W;
      float f = -10.0;
      W = normalize( vec3(vPosition.x, vPosition.y, -f) );
      V = vec3(0.,0.,0.);
      vec3 color = vec3(0., 0., 0.);

     
      //float u = 0.4 * (turbulence(vec3((sin(vPosition.x)+sin(vPosition.y)) * 1.5, (sin(vPosition.x)+sin(vPosition.y)) * 1.5-uTime/2., uTime/5.+10.)) + 1.8);
      float u = 0.4 * (turbulence(vec3(vPosition.x * 1.5, vPosition.y * 1.5-uTime/2., uTime/5.+10.)) + 1.8);      
      float s = pow(0.5 + 0.5 * sin(4. * vPosition.x +uTime/2.+ 6. * u) * cos(4. * vPosition.y+uTime/2. + 6. * u), 1.1);
      color = vec3(s, s*s, s*s*s);
      vec3 colorrfl2 = vec3(.9,.5,0.1);   
      color = mix(color , colorrfl2, 0.3);
      color = mix(color , vec3(0.5,0.5,0.5), (0.+0.5*vPosition.y));

      gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
   }
</script>



<script id='my_vertex_shader5' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader5' type='x-shader/x-fragment'>

   precision mediump float;
   uniform float uTime;
   uniform vec3  uCursor;
   varying vec3  vPosition;

   vec4 sphere1;
   vec4 sphere2;
   vec3 material;

   vec3 Lrgb;
   vec3 Ldir;
   float mode = 2.; //select mode=1. to phong or mode=2. to blinn
   // Compute intersection of a ray with a sphere, if any.  Return t.
   // If there is no intersection, return 10000.

 
   vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
   vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
   vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

   float noise(vec3 P) {
	   vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
	   vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
	   vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
	   vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
	   vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
	   vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
	   vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
	   gx0 = fract(gx0); gx1 = fract(gx1);
	   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
	   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
	   gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
	   gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
	   vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
		    g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
		    g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
		    g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
	   vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
	   vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
	   g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
	   g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
	   vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
		                  dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
		             vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
		                  dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
	   return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
   }
 
   float turbulence(vec3 p) { 
       float sum=0.;
       for (int i =0; i<6; i++){
           sum += abs( noise( pow(2.,float(i)) * p ) ) / pow(2.,float(i));
       }
       return sum;
   }
   float raySphere(vec3 V, vec3 W, vec4 s) {
      float b = 2. * dot(V -= s.xyz, W);
      float c = dot(V, V) - s.w * s.w;
      float d = b * b - 4. * c;
      return d < 0. ? 1. / 0. : (-b + sqrt(d)) / 2.;
   }

   float raySphere2(vec3 V, vec3 W, vec4 s) {
      float b = 2. * dot(V -= s.xyz, W);
      float c = dot(V, V) - s.w * s.w;
      float d = b * b - 4. * c;
      return d < 0. ? 1. / 0. : (-b - sqrt(d)) / 2.;
   }
   // Diffusely shade a sphere.
   //    point is the x,y,z position of the surface point.
   //    sphere is the x,y,z,r definition of the sphere.
   //    material is the r,g,b color of the sphere.

   vec3 shadeSphere(vec3 point, vec4 sphere, vec3 material, vec3 W) {
      float e = noise(vec3(vPosition.x * 15. , vPosition.y * 15., 10.));
      vec3 color = vec3(0.,0.,0.);
      vec3 ambient = material / 5. +(-0.1+0.05*e);
      vec3 diffuse = vec3(0.4,0.4,0.4);
      vec3 s = vec3((1.,1.,1.));

      vec3 normal = (point+ 0.05*e - sphere.xyz) / sphere.w; 
      float p;
	  if (mode ==1.){  //phong
          vec3 R = 2. * dot(normal, Ldir) * normal - Ldir; //Reflectance
          p = 10.;
		  color = ambient + Lrgb * ( diffuse * max(0., dot(normal, Ldir)) + s.rgb * pow(max(0., dot(W, R)), p) ) ; //put the pow inside max 
      }else{  //blinn
          vec3 H = normalize(Ldir + W);
          p = 30.;
          color = ambient + Lrgb * ( diffuse * max(0., dot(normal, Ldir)) + s.rgb * pow(max(0., dot(normal, H)), p) ) ; //put the pow inside max 
      }

      return color;
   }

   void main(void) {
      vec2 c = uCursor.xy;

      Lrgb = vec3(1.,0.5,0.5);
      Ldir = normalize(vec3(c.x, c.y, 1. - 2. * dot(c, c)));
      
      // YOU NEED TO COMPUTE V AND W TO CREATE THE RAY FOR THIS PIXEL,
      // USING vPosition.x AND vPosition.y.
 
      vec3 V, W;
      float f = -10.0;
      W = normalize( vec3(vPosition.x, vPosition.y, -f) );
      V = vec3(0.,0.,0.);
      vec4 spheres[3];
      float e = noise(vec3(vPosition.x * 15. , vPosition.y * 15., 10.));
      spheres[0] = vec4(.2+ 0.012*e,.0+ 0.012*e,5.,.2) ;
      spheres[2] = vec4(0.5*c.x + 0.005*e,0.5*c.y + 0.005*e,5.,.10); //vec4(x,y,z,r)
      spheres[1] = vec4(-.2 + 0.0125*e,.0 + 0.0125*e,5.,.15); //vec4(x,y,z,r)

      vec3 materials[3];
      materials[0] = vec3(0.5,0.7,0.7);
      materials[2] = vec3(0.0,0.7,0.0);
      materials[1] = vec3(0.0,0.0,0.7);
      vec3 color = vec3(0., 0., 0.);

      for (int i=0; i<3;i++){
          float t = raySphere(V, W, spheres[i]);
          if (t < 10000.){
              vec3 point = V + t * W ;
              vec3 Vprime = point + 0.0001;
              vec3 Wprime = Ldir;
              vec3 normal = (point - spheres[i].xyz) / spheres[i].w;
              float tprimeMin = 10000.;
              for (int j =0; j<3;j++){
                  if (j!=i){
                      float tprime = raySphere(Vprime, Wprime, spheres[j]);
                      if (tprime <tprimeMin){
                         tprimeMin = tprime;
                      }
                  }
              }
              //if (tprimeMin == 10000.){ //if no object is in the way of the ray  
                  color = shadeSphere(V + t * W, spheres[i], materials[i], W);
                  //do reflection
                  vec3 colorrfl = vec3(0., 0., 0.);
                  float trflMin = 10000.;
                  float trfl;
                  vec3 Wrfl = 2. * dot(normal, -W) * normal + W;
                  vec3 Vrfl = point + 0.0001 * Wrfl;
                  float trfl2 = raySphere(Vrfl, Wrfl, spheres[i]); 
                  for (int j =0; j<3;j++){
                      if (j!=i){
                           trfl = raySphere(Vrfl, Wrfl, spheres[j]);
                           if (trfl < trflMin && trfl <trfl2){
                               trflMin = trfl;
                               colorrfl = shadeSphere(Vrfl + trflMin * Wrfl, spheres[j], materials[j], Wrfl);
                               
                           }
                      }
                  }
                  color = mix(color, colorrfl,0.5);
                  
                  //do refraction
                  vec3 Vrfr = point + 0.0001;
                  vec3 Wrfr = normalize(W * vec3(5.5,5.5,1.0));
                  float trfr = raySphere2(Vrfr, Wrfr, spheres[i]);
                  vec3 pointo = Vrfr + trfr * Wrfr;
                  //vec3 colorrfr = shadeSphere(pointo, spheres[i], materials[i], Wrfr);
                  //color = mix(color, colorrfr, 0.5);
                 
                  vec3 Vrfro = pointo + 0.0001;
                  vec3 Wrfro = W;
                  for (int j =0; j<3;j++){
                      if (j!=i){
                          float trfro = raySphere2(Vrfr, Wrfr, spheres[j]);
                          if (trfro<10000. && trfro<trfr){
                              vec3 colorrfro = shadeSphere(Vrfro + trfro * Wrfro, spheres[j], materials[j], Wrfro);
                              color = mix(color, colorrfro, 0.5);
                          }
                      }
                  }
                           
              //}
          }
      }

      gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
   }
</script>


<script id='my_vertex_shader6' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader6' type='x-shader/x-fragment'>

   precision mediump float;
   uniform float uTime;
   uniform vec3  uCursor;
   varying vec3  vPosition;

   vec4 sphere1;
   vec4 sphere2;
   vec3 material;

   vec3 Lrgb;
   vec3 Ldir;
   float mode = 2.; //select mode=1. to phong or mode=2. to blinn
   // Compute intersection of a ray with a sphere, if any.  Return t.
   // If there is no intersection, return 10000.

 
   vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
   vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
   vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
   vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

   float noise(vec3 P) {
	   vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));
	   vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);
	   vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);
	   vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;
	   vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);
	   vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
	   vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
	   gx0 = fract(gx0); gx1 = fract(gx1);
	   vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));
	   vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));
	   gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);
	   gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);
	   vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),
		    g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),
		    g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),
		    g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);
	   vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));
	   vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));
	   g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;
	   g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;
	   vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),
		                  dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),
		             vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),
		                  dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);
	   return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);
   }
 
   float turbulence(vec3 p) { 
       float sum=0.;
       for (int i =0; i<6; i++){
           sum += abs( noise( pow(2.,float(i)) * p ) ) / pow(2.,float(i));
       }
       return sum;
   }
   float raySphere(vec3 V, vec3 W, vec4 s) {
      float b = 2. * dot(V -= s.xyz, W);
      float c = dot(V, V) - s.w * s.w;
      float d = b * b - 4. * c;
      return d < 0. ? 1. / 0. : (-b + sqrt(d)) / 2.;
   }

   float raySphere2(vec3 V, vec3 W, vec4 s) {
      float b = 2. * dot(V -= s.xyz, W);
      float c = dot(V, V) - s.w * s.w;
      float d = b * b - 4. * c;
      return d < 0. ? 1. / 0. : (-b - sqrt(d)) / 2.;
   }


   // Diffusely shade a sphere.
   //    point is the x,y,z position of the surface point.
   //    sphere is the x,y,z,r definition of the sphere.
   //    material is the r,g,b color of the sphere.

   vec3 shadeSphere(vec3 point, vec4 sphere, vec3 material, vec3 W) {
      float e = noise(vec3(vPosition.x * 15. , vPosition.y * 15., 10.));
      vec3 color = vec3(0.,0.,0.);
      vec3 ambient = material / 5.;
      vec3 diffuse = vec3(0.4,0.4,0.4);
      vec3 s = vec3((1.,1.,1.));

      vec3 normal = (point - sphere.xyz) / sphere.w; 
      float p;
	  if (mode ==1.){  //phong
          vec3 R = 2. * dot(normal, Ldir) * normal - Ldir; //Reflectance
          p = 10.;
		  color = ambient + Lrgb * ( diffuse * max(0., dot(normal, Ldir)) + s.rgb * pow(max(0., dot(W, R)), p) ) ; //put the pow inside max 
      }else{  //blinn
          vec3 H = normalize(Ldir + W);
          p = 30.;
          color = ambient + Lrgb * ( diffuse * max(0., dot(normal, Ldir)) + s.rgb * pow(max(0., dot(normal, H)), p) ) ; //put the pow inside max 
      }

      return color;
   }

   void main(void) {
      vec2 c = uCursor.xy;

      Lrgb = vec3(1.,0.5,0.5);
      Ldir = normalize(vec3(c.x, c.y, 1. - 2. * dot(c, c)));

      vec3 V, W;
      float f = -10.0;
      W = normalize( vec3(vPosition.x, vPosition.y, -f) );
      V = vec3(0.,0.,0.);
      vec4 spheres[3];
      float e = noise(vec3(vPosition.x * 15. , vPosition.y * 15., 10.));
      spheres[0] = vec4(.0,.0,5.,.25) ;
      spheres[1] = vec4(0.5*c.x,0.5*c.y,5.,.10); //vec4(x,y,z,r)
      spheres[2] = vec4(-.3 + 0.0125*e,.0 + 0.0125*e,5.,.1); //vec4(x,y,z,r)

      vec3 materials[3];
      materials[0] = vec3(0.7,0.0,0.0);
      materials[1] = vec3(0.0,0.7,0.0);
      materials[2] = vec3(0.0,0.0,0.7);
      vec3 color = vec3(0., 0., 0.);

      for (int i=0; i<2;i++){
          float t = raySphere(V, W, spheres[i]);
          if (t < 10000.){
              vec3 point = V + t * W ;
              vec3 Vprime = point + 0.0001;
              vec3 Wprime = Ldir;
              vec3 normal = (point - spheres[i].xyz) / spheres[i].w;
              float tprimeMin = 10000.;
              for (int j =0; j<2;j++){
                  if (j!=i){
                      float tprime = raySphere(Vprime, Wprime, spheres[j]);
                      if (tprime <tprimeMin){
                         tprimeMin = tprime;
                      }
                  }
              }
              //if (tprimeMin == 10000.){ //if no object is in the way of the ray   

                  color = shadeSphere(point, spheres[i], materials[i], W);
                  //do reflection
                  vec3 colorrfl = vec3(0., 0., 0.);
                  float trflMin = 10000.;
                  float trfl;
                  vec3 Wrfl = normalize(2. * dot(normal, -W) * normal + W);
                  vec3 Vrfl = point + 0.0001 * Wrfl;
                  float trfl2 = raySphere(Vrfl, Wrfl, spheres[i]); 
                  for (int j =0; j<2;j++){
                      if (j!=i){
                           trfl = raySphere(Vrfl, Wrfl, spheres[j]);
                           if (trfl < trflMin && trfl <trfl2){
                               trflMin = trfl;
                               colorrfl = shadeSphere(Vrfl + trflMin * Wrfl, spheres[j], materials[j], Wrfl);
                               
                           }
                      }
                  }
                  //color = mix(color, colorrfl, 0.5);    
              
                  //do refraction
                  vec3 Vrfr = point + 0.0001;
                  vec3 Wrfr = normalize(W * vec3(5.5,5.5,1.0));
                  float trfr = raySphere2(Vrfr, Wrfr, spheres[i]);
                  vec3 pointo = Vrfr + trfr * Wrfr;
                  //vec3 colorrfr = shadeSphere(pointo, spheres[i], materials[i], Wrfr);
                  //color = mix(color, colorrfr, 0.5);
                 
                  vec3 Vrfro = pointo + 0.0001;
                  vec3 Wrfro = W;
                  for (int j =0; j<2;j++){
                      if (j!=i){
                          float trfro = raySphere2(Vrfr, Wrfr, spheres[j]);
                          if (trfro<10000. && trfro<trfr){
                              vec3 colorrfro = shadeSphere(Vrfro + trfro * Wrfro, spheres[j], materials[j], Wrfro);
                              color = mix(color, colorrfro, 0.5);
                          }
                      }
                  }
              //}
          }
      }

      gl_FragColor = vec4(sqrt(color), 1.); // Do Gamma correction.
   }
</script>



<br>
<br>
<body bgcolor=gray>
<center>

<tr><font color="white">Cubes</font></tr><br>
<tr><canvas id='canvas1' width=400 height=400></canvas></tr><br>
<br><br><br><br><br><br><br><br><br><br><br><br>

<tr><font color="white">Cilinder</font></tr><br>
<tr><canvas id='canvas8' width=400 height=400></canvas></tr><br>
<br><br><br><br><br><br><br><br><br><br><br><br>

<tr><font color="white">Wind</font></tr><br>
<tr><canvas id='canvas2' width=600 height=600></canvas></tr><br>
<br><br><br><br><br><br><br><br><br><br><br><br>

<tr><font color="white">Fire</font></tr><br>
<tr><canvas id='canvas4' width=600 height=600></canvas></tr><br>
<br><br><br><br><br><br><br><br><br><br><br><br>

<tr><font color="white">Refraction</font></tr><br>
<tr><canvas id='canvas6' width=600 height=600></canvas></tr><br>
<br><br><br><br><br><br><br><br><br><br><br><br>

<tr><font color="white">Reflection + Refraction + Noise Texture</font></tr><br>
<tr><canvas id='canvas5' width=600 height=600></canvas></tr><br>
<br><br><br><br><br><br><br><br><br><br><br><br>

</center>
</body>


<script>
start_gl('canvas1', document.getElementById('my_vertex_shader1'  ).innerHTML,
                    document.getElementById('my_fragment_shader1').innerHTML);
start_gl('canvas2', document.getElementById('my_vertex_shader2'  ).innerHTML,
                    document.getElementById('my_fragment_shader2').innerHTML);
start_gl('canvas3', document.getElementById('my_vertex_shader3'  ).innerHTML,
                    document.getElementById('my_fragment_shader3').innerHTML);
start_gl('canvas4', document.getElementById('my_vertex_shader4'  ).innerHTML,
                   document.getElementById('my_fragment_shader4').innerHTML);
start_gl('canvas5', document.getElementById('my_vertex_shader5'  ).innerHTML,
                    document.getElementById('my_fragment_shader5').innerHTML);
start_gl('canvas6', document.getElementById('my_vertex_shader6'  ).innerHTML,
                    document.getElementById('my_fragment_shader6').innerHTML);
start_gl('canvas7', document.getElementById('my_vertex_shader7'  ).innerHTML,
                    document.getElementById('my_fragment_shader7').innerHTML);
start_gl('canvas8', document.getElementById('my_vertex_shader8'  ).innerHTML,
                    document.getElementById('my_fragment_shader8').innerHTML);

</script>

